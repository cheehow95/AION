"""
AION Language Server Protocol (LSP) Implementation
Provides IDE features: code completion, diagnostics, hover info.
Auto-generated by self-development cycle.
"""

import json
import sys
from typing import Dict, List, Any, Optional
from dataclasses import dataclass

# LSP Message Types
class MessageType:
    ERROR = 1
    WARNING = 2
    INFO = 3
    LOG = 4

@dataclass
class Position:
    line: int
    character: int

@dataclass
class Range:
    start: Position
    end: Position

@dataclass
class Diagnostic:
    range: Range
    message: str
    severity: int = MessageType.ERROR
    source: str = "aion"

@dataclass
class CompletionItem:
    label: str
    kind: int
    detail: str = ""
    documentation: str = ""
    insert_text: str = ""

# Completion item kinds
class CompletionItemKind:
    KEYWORD = 14
    SNIPPET = 15
    CLASS = 7
    FUNCTION = 3
    VARIABLE = 6

class AIONLanguageServer:
    """
    Language Server for AION.
    Provides intelligent editing features.
    """
    
    def __init__(self):
        self.documents: Dict[str, str] = {}
        self.diagnostics: Dict[str, List[Diagnostic]] = {}
        
        # AION keywords for completion
        self.keywords = [
            ("agent", "Declare an agent", "agent ${1:Name} {\n  goal \"${2:description}\"\n  $0\n}"),
            ("model", "Declare a model", "model ${1:Name} {\n  provider = \"${2:openai}\"\n}"),
            ("tool", "Declare a tool", "tool ${1:name}"),
            ("memory", "Declare memory", "memory ${1|working,episodic,long_term,semantic|}"),
            ("goal", "Set agent goal", "goal \"${1:description}\""),
            ("on", "Event handler", "on ${1|input,error,complete|}(${2:param}):\n  $0"),
            ("think", "Reasoning: think", "think"),
            ("analyze", "Reasoning: analyze", "analyze ${1:target}"),
            ("reflect", "Reasoning: reflect", "reflect"),
            ("decide", "Reasoning: decide", "decide ${1:target}"),
            ("if", "Conditional", "if ${1:condition}:\n  $0"),
            ("respond", "Send response", "respond ${1:value}"),
            ("store", "Store in memory", "store ${1:value} in ${2:memory}"),
            ("recall", "Recall from memory", "recall from ${1:memory}"),
            ("use", "Use a tool", "use ${1:tool}(${2:args})"),
            ("emit", "Emit event", "emit ${1:event}(${2:args})"),
            ("policy", "Define policy", "policy {\n  $0\n}"),
        ]
        
    def did_open(self, uri: str, text: str):
        """Document opened."""
        self.documents[uri] = text
        self._validate(uri)
        
    def did_change(self, uri: str, text: str):
        """Document changed."""
        self.documents[uri] = text
        self._validate(uri)
        
    def did_close(self, uri: str):
        """Document closed."""
        if uri in self.documents:
            del self.documents[uri]
        if uri in self.diagnostics:
            del self.diagnostics[uri]
    
    def _validate(self, uri: str):
        """Validate document and produce diagnostics."""
        text = self.documents.get(uri, "")
        diagnostics = []
        
        try:
            # Try to parse
            sys.path.insert(0, '.')
            from src.parser import parse
            from src.lexer import tokenize
            
            tokens = tokenize(text)
            ast = parse(text)
            
            # No errors - clear diagnostics
            self.diagnostics[uri] = []
            
        except Exception as e:
            # Extract line/column from error if possible
            error_msg = str(e)
            line = 0
            col = 0
            
            # Try to parse "line X, column Y" from error
            import re
            match = re.search(r'line (\d+), column (\d+)', error_msg)
            if match:
                line = int(match.group(1)) - 1
                col = int(match.group(2)) - 1
            
            diagnostics.append(Diagnostic(
                range=Range(Position(line, col), Position(line, col + 10)),
                message=error_msg,
                severity=MessageType.ERROR
            ))
            
        self.diagnostics[uri] = diagnostics
        
    def get_completions(self, uri: str, position: Position) -> List[CompletionItem]:
        """Get completion items at position."""
        text = self.documents.get(uri, "")
        lines = text.splitlines() if text else [""]  # Handle empty documents
        
        if position.line >= len(lines):
            return []
            
        line = lines[position.line]
        prefix = line[:position.character].strip()
        
        completions = []
        
        # Context-aware completions
        in_agent = any("agent " in l and "{" in l for l in lines[:position.line])
        
        for keyword, detail, snippet in self.keywords:
            if keyword.startswith(prefix.lower()) or not prefix:
                # Filter based on context
                if in_agent or keyword in ("agent", "model", "tool", "policy"):
                    completions.append(CompletionItem(
                        label=keyword,
                        kind=CompletionItemKind.KEYWORD,
                        detail=detail,
                        insert_text=snippet
                    ))
        
        return completions
    
    def get_hover(self, uri: str, position: Position) -> Optional[str]:
        """Get hover information."""
        text = self.documents.get(uri, "")
        lines = text.splitlines()
        
        if position.line >= len(lines):
            return None
            
        line = lines[position.line]
        
        # Find word at position
        import re
        words = re.findall(r'\b\w+\b', line)
        
        hover_docs = {
            "agent": "**agent** - Declares an autonomous AI agent with goals, memory, and behaviors.",
            "goal": "**goal** - Defines the agent's primary objective.",
            "memory": "**memory** - Declares a memory system (working, episodic, long_term, semantic).",
            "model": "**model** - Declares an LLM provider configuration.",
            "tool": "**tool** - Declares or references an external tool.",
            "think": "**think** - Triggers cognitive reasoning about the current context.",
            "analyze": "**analyze** - Deeply examines the target for patterns and insights.",
            "reflect": "**reflect** - Reviews past actions and outcomes.",
            "decide": "**decide** - Makes a decision based on reasoning.",
            "respond": "**respond** - Sends output to the user or caller.",
            "store": "**store** - Saves data to a memory system.",
            "recall": "**recall** - Retrieves data from memory.",
            "policy": "**policy** - Defines governance rules and constraints.",
        }
        
        for word in words:
            if word.lower() in hover_docs:
                return hover_docs[word.lower()]
        
        return None
    
    def get_diagnostics(self, uri: str) -> List[Diagnostic]:
        """Get current diagnostics."""
        return self.diagnostics.get(uri, [])


# Simple stdio server for testing
def run_server():
    """Run the language server."""
    server = AIONLanguageServer()
    
    print("AION Language Server started", file=sys.stderr)
    
    while True:
        try:
            # Read header
            header = {}
            while True:
                line = sys.stdin.readline()
                if not line or line == '\r\n':
                    break
                if ':' in line:
                    key, value = line.split(':', 1)
                    header[key.strip()] = value.strip()
            
            if 'Content-Length' not in header:
                continue
                
            # Read content
            length = int(header['Content-Length'])
            content = sys.stdin.read(length)
            
            message = json.loads(content)
            method = message.get('method', '')
            params = message.get('params', {})
            
            # Handle methods
            response = None
            
            if method == 'initialize':
                response = {
                    'capabilities': {
                        'textDocumentSync': 1,
                        'completionProvider': {'triggerCharacters': ['.', ' ']},
                        'hoverProvider': True,
                    }
                }
            elif method == 'textDocument/didOpen':
                doc = params['textDocument']
                server.did_open(doc['uri'], doc['text'])
            elif method == 'textDocument/didChange':
                doc = params['textDocument']
                changes = params['contentChanges']
                if changes:
                    server.did_change(doc['uri'], changes[0]['text'])
            elif method == 'textDocument/completion':
                pos = params['position']
                items = server.get_completions(
                    params['textDocument']['uri'],
                    Position(pos['line'], pos['character'])
                )
                response = [{'label': i.label, 'kind': i.kind, 'detail': i.detail} for i in items]
            elif method == 'textDocument/hover':
                pos = params['position']
                content = server.get_hover(
                    params['textDocument']['uri'],
                    Position(pos['line'], pos['character'])
                )
                if content:
                    response = {'contents': {'kind': 'markdown', 'value': content}}
            
            # Send response
            if response is not None and 'id' in message:
                result = json.dumps({'id': message['id'], 'result': response})
                sys.stdout.write(f'Content-Length: {len(result)}\r\n\r\n{result}')
                sys.stdout.flush()
                
        except Exception as e:
            print(f"LSP Error: {e}", file=sys.stderr)


if __name__ == "__main__":
    run_server()
