"""
AION Python Code Generator
Transpiles AION AST to executable Python code.
"""

from typing import Any, Optional
from ..parser import (
    ASTNode, ASTVisitor, Program,
    AgentDecl, GoalStmt, MemoryDecl, ModelDecl, ModelRef, ToolDecl, ToolRef, PolicyDecl,
    EventHandler,
    ThinkStmt, AnalyzeStmt, ReflectStmt, DecideStmt,
    IfStmt, WhenStmt, RepeatStmt,
    UseStmt, RespondStmt, EmitStmt, StoreStmt, RecallStmt, AssignStmt,
    Expression, BinaryExpr, UnaryExpr, Literal, Identifier, MemberAccess, ListLiteral
)


class CodeGenerator(ASTVisitor):
    """
    Generates Python code from AION AST.
    Outputs code that integrates with LangChain or raw OpenAI API.
    """
    
    def __init__(self, use_langchain: bool = False):
        self.use_langchain = use_langchain
        self.indent_level = 0
        self.output_lines: list[str] = []
        self.imports: set[str] = set()
    
    def generate(self, program: Program) -> str:
        """Generate Python code from program."""
        self._reset()
        
        # Visit all declarations
        for decl in program.declarations:
            self.visit(decl)
            self.emit("")
        
        # Build final output
        return self._build_output()
    
    def _reset(self) -> None:
        """Reset generator state."""
        self.indent_level = 0
        self.output_lines = []
        self.imports = {
            "import asyncio",
            "from typing import Any, Optional",
            "from dataclasses import dataclass, field",
        }
    
    def _build_output(self) -> str:
        """Build the final Python output."""
        header = [
            '"""',
            'Auto-generated Python code from AION source.',
            'Generated by AION Transpiler',
            '"""',
            '',
        ]
        
        # Add imports
        imports_list = sorted(self.imports)
        imports_list.append('')
        
        # Add runtime imports
        runtime_imports = [
            '# AION Runtime',
            'from aion.runtime import (',
            '    WorkingMemory, EpisodicMemory, LongTermMemory, SemanticMemory,',
            '    ModelRegistry, ToolRegistry,',
            '    ReasoningEngine, Message',
            ')',
            '',
        ]
        
        all_lines = header + imports_list + runtime_imports + self.output_lines
        return '\n'.join(all_lines)
    
    def emit(self, line: str) -> None:
        """Emit a line of code with current indentation."""
        if line:
            self.output_lines.append('    ' * self.indent_level + line)
        else:
            self.output_lines.append('')
    
    def indent(self) -> None:
        """Increase indentation."""
        self.indent_level += 1
    
    def dedent(self) -> None:
        """Decrease indentation."""
        self.indent_level = max(0, self.indent_level - 1)
    
    def visit(self, node: ASTNode) -> Any:
        """Visit a node."""
        method_name = f'visit_{node.__class__.__name__}'
        method = getattr(self, method_name, self.generic_visit)
        return method(node)
    
    def generic_visit(self, node: ASTNode) -> None:
        """Default visit - emit comment."""
        self.emit(f"# TODO: {node.__class__.__name__}")
    
    # ============ Declarations ============
    
    def visit_AgentDecl(self, node: AgentDecl) -> None:
        """Generate agent class."""
        class_name = node.name
        
        self.emit("@dataclass")
        self.emit(f"class {class_name}Agent:")
        self.indent()
        self.emit('"""AION Agent: {class_name}"""')
        self.emit("")
        
        # Extract metadata from body
        goal = ""
        memories = []
        model_ref = None
        tools = []
        policies = {}
        handlers = []
        
        for member in node.body:
            if isinstance(member, GoalStmt):
                goal = member.goal
            elif isinstance(member, MemoryDecl):
                memories.append(member)
            elif isinstance(member, ModelRef):
                model_ref = member.name
            elif isinstance(member, ToolRef):
                tools.append(member.name)
            elif isinstance(member, PolicyDecl):
                policies.update(member.config)
            elif isinstance(member, EventHandler):
                handlers.append(member)
        
        # Class attributes
        self.emit(f'goal: str = "{goal}"')
        self.emit("")
        
        # Memory initialization
        for mem in memories:
            mem_class = {
                'working': 'WorkingMemory',
                'episodic': 'EpisodicMemory',
                'long_term': 'LongTermMemory',
                'semantic': 'SemanticMemory',
            }.get(mem.memory_type, 'WorkingMemory')
            
            config_str = repr(mem.config) if mem.config else 'None'
            self.emit(f'{mem.memory_type}_memory: {mem_class} = field(default_factory=lambda: {mem_class}(config={config_str}))')
        
        if memories:
            self.emit("")
        
        # Model reference
        if model_ref:
            self.emit(f'model_name: str = "{model_ref}"')
            self.emit("model: Any = None")
            self.emit("")
        
        # Tool list
        if tools:
            tools_str = repr(tools)
            self.emit(f'tools: list[str] = field(default_factory=lambda: {tools_str})')
            self.emit("")
        
        # Policies
        if policies:
            policies_str = repr(policies)
            self.emit(f'policies: dict = field(default_factory=lambda: {policies_str})')
            self.emit("")
        
        # Runtime components
        self.emit("reasoning_engine: ReasoningEngine = field(default_factory=ReasoningEngine)")
        self.emit("tool_registry: ToolRegistry = field(default_factory=ToolRegistry)")
        self.emit("context: dict = field(default_factory=dict)")
        self.emit("")
        
        # Setup method
        self.emit("async def setup(self) -> None:")
        self.indent()
        self.emit('"""Initialize the agent."""')
        if model_ref:
            self.emit(f'self.model = ModelRegistry.get_model("{model_ref}")')
            self.emit("self.reasoning_engine.model = self.model")
        else:
            self.emit("pass")
        self.dedent()
        self.emit("")
        
        # Generate event handlers
        for handler in handlers:
            self._generate_handler(handler)
        
        self.dedent()
    
    def _generate_handler(self, handler: EventHandler) -> None:
        """Generate event handler method."""
        method_name = f"on_{handler.event_type}"
        params = ", ".join(handler.params) if handler.params else ""
        
        self.emit(f"async def {method_name}(self{', ' + params if params else ''}) -> Any:")
        self.indent()
        self.emit(f'"""Handle {handler.event_type} event."""')
        
        # Generate body statements
        for stmt in handler.body:
            self._generate_statement(stmt)
        
        self.dedent()
        self.emit("")
    
    def _generate_statement(self, stmt: ASTNode) -> None:
        """Generate a statement."""
        if isinstance(stmt, ThinkStmt):
            prompt = repr(stmt.prompt) if stmt.prompt else 'None'
            self.emit(f"await self.reasoning_engine.think({prompt}, self.context)")
        
        elif isinstance(stmt, AnalyzeStmt):
            target = self._generate_expr(stmt.target)
            self.emit(f"await self.reasoning_engine.analyze({target}, self.context)")
        
        elif isinstance(stmt, ReflectStmt):
            if stmt.target:
                target = self._generate_expr(stmt.target)
                self.emit(f"await self.reasoning_engine.reflect({target}, self.context)")
            else:
                self.emit("await self.reasoning_engine.reflect(None, self.context)")
        
        elif isinstance(stmt, DecideStmt):
            target = self._generate_expr(stmt.target)
            self.emit(f"result = await self.reasoning_engine.decide({target}, self.context)")
        
        elif isinstance(stmt, IfStmt):
            condition = self._generate_expr(stmt.condition)
            self.emit(f"if {condition}:")
            self.indent()
            for s in stmt.then_body:
                self._generate_statement(s)
            if not stmt.then_body:
                self.emit("pass")
            self.dedent()
            if stmt.else_body:
                self.emit("else:")
                self.indent()
                for s in stmt.else_body:
                    self._generate_statement(s)
                self.dedent()
        
        elif isinstance(stmt, WhenStmt):
            condition = self._generate_expr(stmt.condition)
            self.emit(f"if {condition}:")
            self.indent()
            for s in stmt.body:
                self._generate_statement(s)
            if not stmt.body:
                self.emit("pass")
            self.dedent()
        
        elif isinstance(stmt, RepeatStmt):
            if stmt.times:
                times = self._generate_expr(stmt.times)
                self.emit(f"for _ in range(int({times})):")
            else:
                self.emit("while True:")
            self.indent()
            for s in stmt.body:
                self._generate_statement(s)
            if not stmt.body:
                self.emit("pass")
            self.dedent()
        
        elif isinstance(stmt, UseStmt):
            args = ", ".join(self._generate_expr(a) for a in stmt.args)
            self.emit(f'result = await self.tool_registry.execute("{stmt.tool_name}", {args})')
        
        elif isinstance(stmt, RespondStmt):
            if stmt.value:
                value = self._generate_expr(stmt.value)
                self.emit(f"return {value}")
            else:
                self.emit("return None")
        
        elif isinstance(stmt, StoreStmt):
            value = self._generate_expr(stmt.value)
            memory = stmt.memory_name or 'working'
            self.emit(f"self.{memory}_memory.store({value})")
        
        elif isinstance(stmt, RecallStmt):
            memory = stmt.memory_name or 'working'
            if stmt.condition:
                query = self._generate_expr(stmt.condition)
                self.emit(f"memories = self.{memory}_memory.recall({query})")
            else:
                self.emit(f"memories = self.{memory}_memory.recall()")
        
        elif isinstance(stmt, AssignStmt):
            value = self._generate_expr(stmt.value)
            self.emit(f"{stmt.name} = {value}")
        
        else:
            self.emit(f"# TODO: {stmt.__class__.__name__}")
    
    def _generate_expr(self, expr: Expression) -> str:
        """Generate expression code."""
        if isinstance(expr, Literal):
            return repr(expr.value)
        
        elif isinstance(expr, Identifier):
            return expr.name
        
        elif isinstance(expr, BinaryExpr):
            left = self._generate_expr(expr.left)
            right = self._generate_expr(expr.right)
            return f"({left} {expr.operator} {right})"
        
        elif isinstance(expr, UnaryExpr):
            operand = self._generate_expr(expr.operand)
            return f"({expr.operator} {operand})"
        
        elif isinstance(expr, MemberAccess):
            obj = self._generate_expr(expr.object)
            return f"{obj}.{expr.member}"
        
        elif isinstance(expr, ListLiteral):
            elements = ", ".join(self._generate_expr(e) for e in expr.elements)
            return f"[{elements}]"
        
        return "None"
    
    def visit_ModelDecl(self, node: ModelDecl) -> None:
        """Generate model registration."""
        config_str = repr(node.config)
        provider = node.config.get('provider', 'openai')
        
        self.emit(f'# Register model: {node.name}')
        self.emit(f'ModelRegistry.create_model("{node.name}", provider="{provider}", config={config_str})')
    
    def visit_ToolDecl(self, node: ToolDecl) -> None:
        """Generate tool declaration."""
        config_str = repr(node.config)
        trust = node.config.get('trust', 'medium')
        cost = node.config.get('cost', 'low')
        
        self.emit(f'# Tool declaration: {node.name}')
        self.emit(f'# Register with: tool_registry.register("{node.name}", handler, trust="{trust}", cost="{cost}")')
    
    def visit_PolicyDecl(self, node: PolicyDecl) -> None:
        """Generate policy configuration."""
        self.emit(f'# Policy: {node.name or "global"}')
        for key, value in node.config.items():
            self.emit(f'# {key} = {value}')


def transpile(source: str, use_langchain: bool = False) -> str:
    """
    Transpile AION source code to Python.
    
    Args:
        source: AION source code
        use_langchain: Whether to generate LangChain code
    
    Returns:
        Generated Python code
    """
    from ..parser import parse
    
    program = parse(source)
    generator = CodeGenerator(use_langchain=use_langchain)
    return generator.generate(program)
