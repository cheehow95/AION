"""
AION Agent-to-Agent Communication Protocol
Enables message passing between agents.
Auto-generated by self-development cycle.
"""

import asyncio
import uuid
from typing import Any, Dict, List, Callable, Optional
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum

class MessagePriority(Enum):
    LOW = 0
    NORMAL = 1
    HIGH = 2
    CRITICAL = 3

@dataclass
class AgentMessage:
    """Message passed between agents."""
    sender: str
    recipient: str
    content: Any
    message_type: str = "message"
    priority: MessagePriority = MessagePriority.NORMAL
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())
    reply_to: Optional[str] = None
    requires_response: bool = False
    ttl: int = 60  # Seconds until expiry

@dataclass
class AgentAddress:
    """Address of an agent in the network."""
    name: str
    node: str = "local"
    namespace: str = "default"
    
    def __str__(self):
        return f"{self.namespace}/{self.node}/{self.name}"

class MessageBroker:
    """
    Central message broker for agent communication.
    Handles routing, queuing, and delivery.
    """
    
    def __init__(self):
        self.agents: Dict[str, 'AgentMailbox'] = {}
        self.subscriptions: Dict[str, List[str]] = {}  # topic -> [agent_names]
        self.message_log: List[AgentMessage] = []
        
    def register(self, name: str) -> 'AgentMailbox':
        """Register an agent with the broker."""
        if name not in self.agents:
            self.agents[name] = AgentMailbox(name, self)
        return self.agents[name]
    
    def unregister(self, name: str):
        """Unregister an agent."""
        if name in self.agents:
            del self.agents[name]
    
    async def send(self, message: AgentMessage) -> bool:
        """Send a message to an agent."""
        self.message_log.append(message)
        
        if message.recipient == "*":
            # Broadcast
            for agent in self.agents.values():
                if agent.name != message.sender:
                    await agent.receive(message)
            return True
        elif message.recipient in self.agents:
            await self.agents[message.recipient].receive(message)
            return True
        
        return False
    
    def subscribe(self, agent_name: str, topic: str):
        """Subscribe agent to a topic."""
        if topic not in self.subscriptions:
            self.subscriptions[topic] = []
        if agent_name not in self.subscriptions[topic]:
            self.subscriptions[topic].append(agent_name)
    
    async def publish(self, topic: str, message: AgentMessage):
        """Publish message to all subscribers of a topic."""
        if topic in self.subscriptions:
            for agent_name in self.subscriptions[topic]:
                if agent_name in self.agents:
                    await self.agents[agent_name].receive(message)

class AgentMailbox:
    """
    Mailbox for an individual agent.
    Handles incoming/outgoing messages.
    """
    
    def __init__(self, name: str, broker: MessageBroker):
        self.name = name
        self.broker = broker
        self.inbox: asyncio.Queue = asyncio.Queue()
        self.handlers: Dict[str, Callable] = {}
        self.pending_replies: Dict[str, asyncio.Future] = {}
        
    async def send(self, recipient: str, content: Any, 
                   message_type: str = "message",
                   priority: MessagePriority = MessagePriority.NORMAL,
                   requires_response: bool = False) -> Optional[AgentMessage]:
        """Send a message to another agent."""
        message = AgentMessage(
            sender=self.name,
            recipient=recipient,
            content=content,
            message_type=message_type,
            priority=priority,
            requires_response=requires_response
        )
        
        if requires_response:
            future = asyncio.Future()
            self.pending_replies[message.id] = future
            await self.broker.send(message)
            return await asyncio.wait_for(future, timeout=message.ttl)
        else:
            await self.broker.send(message)
            return None
    
    async def receive(self, message: AgentMessage):
        """Receive a message into the inbox."""
        # Check if this is a reply
        if message.reply_to and message.reply_to in self.pending_replies:
            self.pending_replies[message.reply_to].set_result(message)
            del self.pending_replies[message.reply_to]
            return
        
        await self.inbox.put(message)
        
        # Auto-dispatch to handlers
        if message.message_type in self.handlers:
            await self.handlers[message.message_type](message)
    
    async def reply(self, original: AgentMessage, content: Any):
        """Reply to a message."""
        reply = AgentMessage(
            sender=self.name,
            recipient=original.sender,
            content=content,
            message_type="reply",
            reply_to=original.id
        )
        await self.broker.send(reply)
    
    def on(self, message_type: str, handler: Callable):
        """Register a message handler."""
        self.handlers[message_type] = handler
    
    async def get_message(self, timeout: float = None) -> Optional[AgentMessage]:
        """Get next message from inbox."""
        try:
            return await asyncio.wait_for(self.inbox.get(), timeout=timeout)
        except asyncio.TimeoutError:
            return None


# Global broker instance
_global_broker = MessageBroker()

def get_broker() -> MessageBroker:
    """Get the global message broker."""
    return _global_broker


# Demo
async def demo_messaging():
    """Demonstrate agent-to-agent communication."""
    print("ðŸ“¨ Agent-to-Agent Communication Demo")
    print("-" * 40)
    
    broker = get_broker()
    
    # Create two agents
    alice = broker.register("Alice")
    bob = broker.register("Bob")
    
    # Bob's message handler
    async def bob_handler(msg: AgentMessage):
        print(f"  [Bob] Received from {msg.sender}: {msg.content}")
        if msg.requires_response:
            await bob.reply(msg, f"Hello {msg.sender}! Message received.")
    
    bob.on("message", bob_handler)
    
    # Alice sends to Bob
    print("  [Alice] Sending message to Bob...")
    response = await alice.send("Bob", "Hello Bob!", requires_response=True)
    
    if response:
        print(f"  [Alice] Got reply: {response.content}")
    
    print("-" * 40)
    print("âœ… Messaging demo complete!")


if __name__ == "__main__":
    asyncio.run(demo_messaging())
