<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AION Complete Protein Folding System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0c0c1e 0%, #1a1a3e 50%, #0d2137 100%);
            min-height: 100vh;
            color: #e0e0e0;
            overflow-x: hidden;
        }
        
        .container {
            display: grid;
            grid-template-columns: 380px 1fr;
            height: 100vh;
        }
        
        .sidebar {
            background: rgba(15, 15, 35, 0.95);
            padding: 25px;
            overflow-y: auto;
            border-right: 1px solid rgba(100, 150, 255, 0.2);
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 30px;
        }
        
        .logo-icon {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #00d4ff, #7c3aed);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }
        
        .logo h1 {
            font-size: 1.6rem;
            background: linear-gradient(135deg, #00d4ff, #a855f7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .logo span {
            font-size: 0.75rem;
            color: #888;
        }
        
        .section {
            margin-bottom: 25px;
        }
        
        .section-title {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
            margin-bottom: 12px;
        }
        
        .input-group {
            margin-bottom: 15px;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 6px;
            font-size: 0.9rem;
            color: #aaa;
        }
        
        .input-group input, .input-group select, .input-group textarea {
            width: 100%;
            padding: 12px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(100,150,255,0.2);
            border-radius: 8px;
            color: #fff;
            font-family: 'Fira Code', monospace;
            font-size: 0.9rem;
        }
        
        .input-group textarea {
            height: 80px;
            resize: vertical;
        }
        
        .input-group input:focus, .input-group select:focus, .input-group textarea:focus {
            outline: none;
            border-color: #00d4ff;
            box-shadow: 0 0 15px rgba(0,212,255,0.2);
        }
        
        .btn {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, #00d4ff, #7c3aed);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 10px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,212,255,0.3);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn-secondary {
            background: rgba(255,255,255,0.1);
        }
        
        .presets {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }
        
        .preset-btn {
            padding: 6px 12px;
            background: rgba(100,150,255,0.1);
            border: 1px solid rgba(100,150,255,0.3);
            border-radius: 6px;
            color: #aaa;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .preset-btn:hover {
            background: rgba(0,212,255,0.2);
            border-color: #00d4ff;
            color: #fff;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .stat-card {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(100,150,255,0.15);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }
        
        .stat-label {
            font-size: 0.75rem;
            color: #666;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 1.4rem;
            font-weight: bold;
            background: linear-gradient(135deg, #00d4ff, #a855f7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .progress-container {
            margin: 15px 0;
        }
        
        .progress-bar {
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #7c3aed);
            width: 0%;
            transition: width 0.3s;
        }
        
        .progress-text {
            font-size: 0.8rem;
            color: #888;
            margin-top: 5px;
        }
        
        .viewer {
            position: relative;
            background: radial-gradient(ellipse at center, #1a1a3e 0%, #0c0c1e 100%);
        }
        
        #canvas-3d {
            width: 100%;
            height: 100%;
        }
        
        .viewer-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(15,15,35,0.9);
            padding: 12px 20px;
            border-radius: 30px;
            border: 1px solid rgba(100,150,255,0.2);
        }
        
        .control-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(100,150,255,0.3);
            color: #aaa;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .control-btn:hover {
            background: rgba(0,212,255,0.2);
            border-color: #00d4ff;
            color: #fff;
        }
        
        .control-btn.active {
            background: linear-gradient(135deg, #00d4ff, #7c3aed);
            border-color: transparent;
            color: white;
        }
        
        .info-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(15,15,35,0.9);
            padding: 15px 20px;
            border-radius: 12px;
            border: 1px solid rgba(100,150,255,0.2);
            max-width: 300px;
        }
        
        .info-title {
            font-size: 1rem;
            color: #00d4ff;
            margin-bottom: 10px;
        }
        
        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.85rem;
        }
        
        .info-key { color: #888; }
        .info-value { color: #fff; font-weight: 500; }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(100,150,255,0.1);
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.75rem;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        .log-panel {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 12px;
            height: 150px;
            overflow-y: auto;
            font-family: 'Fira Code', monospace;
            font-size: 0.75rem;
        }
        
        .log-entry {
            margin-bottom: 4px;
            color: #0f0;
        }
        
        .log-entry.error { color: #f55; }
        .log-entry.info { color: #5af; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .loading { animation: pulse 1s infinite; }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="logo">
                <div class="logo-icon">üß¨</div>
                <div>
                    <h1>AION Protein</h1>
                    <span>Complete Folding System</span>
                </div>
            </div>
            
            <div class="section">
                <div class="section-title">üìù Input Sequence</div>
                <div class="input-group">
                    <label>Amino Acid Sequence</label>
                    <textarea id="sequence" placeholder="Enter protein sequence...">KVFGRCELAAAMKRHGLDNYRGYSLGNWVCAAK</textarea>
                </div>
                <div class="presets">
                    <button class="preset-btn" onclick="setPreset('insulin')">Insulin B</button>
                    <button class="preset-btn" onclick="setPreset('lysozyme')">Lysozyme</button>
                    <button class="preset-btn" onclick="setPreset('helix')">Œ±-Helix</button>
                    <button class="preset-btn" onclick="setPreset('sheet')">Œ≤-Sheet</button>
                    <button class="preset-btn" onclick="setPreset('random')">Random</button>
                </div>
            </div>
            
            <div class="section">
                <div class="section-title">‚öôÔ∏è Folding Parameters</div>
                <div class="input-group">
                    <label>Algorithm</label>
                    <select id="algorithm">
                        <option value="physics">Physics-Based Energy Minimization</option>
                        <option value="mc">Monte Carlo Sampling</option>
                        <option value="md">Molecular Dynamics</option>
                        <option value="sa">Simulated Annealing</option>
                    </select>
                </div>
                <div class="input-group">
                    <label>Iterations</label>
                    <select id="iterations">
                        <option value="500">500 (Fast)</option>
                        <option value="1000" selected>1000 (Balanced)</option>
                        <option value="2500">2500 (Quality)</option>
                        <option value="5000">5000 (Best)</option>
                    </select>
                </div>
                <div class="input-group">
                    <label>Temperature (K)</label>
                    <input type="number" id="temperature" value="300" min="100" max="1000">
                </div>
            </div>
            
            <button class="btn" id="fold-btn" onclick="startFolding()">
                ‚ö° Start Folding Simulation
            </button>
            <button class="btn btn-secondary" onclick="resetViewer()">
                üîÑ Reset View
            </button>
            
            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="progress"></div>
                </div>
                <div class="progress-text" id="progress-text">Ready</div>
            </div>
            
            <div class="section">
                <div class="section-title">üìä Structure Statistics</div>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-label">Energy</div>
                        <div class="stat-value" id="stat-energy">-</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Rg (√Ö)</div>
                        <div class="stat-value" id="stat-rg">-</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Helix %</div>
                        <div class="stat-value" id="stat-helix">-</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Sheet %</div>
                        <div class="stat-value" id="stat-sheet">-</div>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <div class="section-title">üìã Simulation Log</div>
                <div class="log-panel" id="log"></div>
            </div>
        </div>
        
        <div class="viewer">
            <canvas id="canvas-3d"></canvas>
            
            <div class="info-overlay">
                <div class="info-title">Structure Info</div>
                <div class="info-item">
                    <span class="info-key">Length</span>
                    <span class="info-value" id="info-length">-</span>
                </div>
                <div class="info-item">
                    <span class="info-key">Method</span>
                    <span class="info-value" id="info-method">Physics-Based</span>
                </div>
                <div class="info-item">
                    <span class="info-key">Confidence</span>
                    <span class="info-value" id="info-confidence">-</span>
                </div>
                <div class="legend">
                    <div class="legend-item"><div class="legend-color" style="background:#ff6b6b"></div>Hydrophobic</div>
                    <div class="legend-item"><div class="legend-color" style="background:#4ecdc4"></div>Polar</div>
                    <div class="legend-item"><div class="legend-color" style="background:#45b7d1"></div>Positive</div>
                    <div class="legend-item"><div class="legend-color" style="background:#f7dc6f"></div>Negative</div>
                    <div class="legend-item"><div class="legend-color" style="background:#bb8fce"></div>Special</div>
                </div>
            </div>
            
            <div class="viewer-controls">
                <button class="control-btn active" onclick="setRenderMode('cartoon')" title="Cartoon">üéóÔ∏è</button>
                <button class="control-btn" onclick="setRenderMode('backbone')" title="Backbone">üìç</button>
                <button class="control-btn" onclick="setRenderMode('spacefill')" title="Space Fill">‚ö™</button>
                <button class="control-btn" onclick="toggleSpin()" title="Auto-rotate">üîÑ</button>
                <button class="control-btn" onclick="toggleLabels()" title="Labels">üè∑Ô∏è</button>
                <button class="control-btn" onclick="exportPDB()" title="Export PDB">üíæ</button>
            </div>
        </div>
    </div>
    
    <script>
        // === THREE.JS SETUP ===
        let scene, camera, renderer, controls;
        let proteinGroup = null;
        let isSpinning = true;
        let showLabels = false;
        let renderMode = 'cartoon';
        
        // Amino acid properties
        const AA_PROPERTIES = {
            'A': { name: 'Alanine', type: 'hydrophobic', color: 0xff6b6b, hydropathy: 1.8 },
            'R': { name: 'Arginine', type: 'positive', color: 0x45b7d1, hydropathy: -4.5 },
            'N': { name: 'Asparagine', type: 'polar', color: 0x4ecdc4, hydropathy: -3.5 },
            'D': { name: 'Aspartate', type: 'negative', color: 0xf7dc6f, hydropathy: -3.5 },
            'C': { name: 'Cysteine', type: 'special', color: 0xbb8fce, hydropathy: 2.5 },
            'E': { name: 'Glutamate', type: 'negative', color: 0xf7dc6f, hydropathy: -3.5 },
            'Q': { name: 'Glutamine', type: 'polar', color: 0x4ecdc4, hydropathy: -3.5 },
            'G': { name: 'Glycine', type: 'special', color: 0xbb8fce, hydropathy: -0.4 },
            'H': { name: 'Histidine', type: 'positive', color: 0x45b7d1, hydropathy: -3.2 },
            'I': { name: 'Isoleucine', type: 'hydrophobic', color: 0xff6b6b, hydropathy: 4.5 },
            'L': { name: 'Leucine', type: 'hydrophobic', color: 0xff6b6b, hydropathy: 3.8 },
            'K': { name: 'Lysine', type: 'positive', color: 0x45b7d1, hydropathy: -3.9 },
            'M': { name: 'Methionine', type: 'hydrophobic', color: 0xff6b6b, hydropathy: 1.9 },
            'F': { name: 'Phenylalanine', type: 'hydrophobic', color: 0xff6b6b, hydropathy: 2.8 },
            'P': { name: 'Proline', type: 'special', color: 0xbb8fce, hydropathy: -1.6 },
            'S': { name: 'Serine', type: 'polar', color: 0x4ecdc4, hydropathy: -0.8 },
            'T': { name: 'Threonine', type: 'polar', color: 0x4ecdc4, hydropathy: -0.7 },
            'W': { name: 'Tryptophan', type: 'hydrophobic', color: 0xff6b6b, hydropathy: -0.9 },
            'Y': { name: 'Tyrosine', type: 'polar', color: 0x4ecdc4, hydropathy: -1.3 },
            'V': { name: 'Valine', type: 'hydrophobic', color: 0xff6b6b, hydropathy: 4.2 }
        };
        
        // Preset sequences
        const PRESETS = {
            insulin: 'FVNQHLCGSHLVEALYLVCGERGFFYTPKA',
            lysozyme: 'KVFGRCELAAAMKRHGLDNYRGYSLGNWVCAAK',
            helix: 'AEAAAKEAAAKEAAAKEAAAK',
            sheet: 'VTVTVTVTVTVTVTVT',
            random: () => {
                const aas = 'ARNDCEQGHILKMFPSTWYV';
                let seq = '';
                for (let i = 0; i < 25; i++) {
                    seq += aas[Math.floor(Math.random() * 20)];
                }
                return seq;
            }
        };
        
        function init3D() {
            const canvas = document.getElementById('canvas-3d');
            const viewer = canvas.parentElement;
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0c0c1e);
            scene.fog = new THREE.Fog(0x0c0c1e, 50, 150);
            
            camera = new THREE.PerspectiveCamera(60, viewer.clientWidth / viewer.clientHeight, 0.1, 1000);
            camera.position.set(0, 0, 50);
            
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(viewer.clientWidth, viewer.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404080, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);
            
            const directionalLight2 = new THREE.DirectionalLight(0x00d4ff, 0.3);
            directionalLight2.position.set(-10, -10, -5);
            scene.add(directionalLight2);
            
            // Add grid helper
            const gridHelper = new THREE.GridHelper(100, 50, 0x222244, 0x111133);
            gridHelper.rotation.x = Math.PI / 2;
            gridHelper.position.z = -30;
            scene.add(gridHelper);
            
            // Mouse controls
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            canvas.addEventListener('mousedown', () => { isDragging = true; });
            canvas.addEventListener('mouseup', () => { isDragging = false; });
            canvas.addEventListener('mousemove', (e) => {
                if (isDragging && proteinGroup) {
                    const deltaMove = {
                        x: e.offsetX - previousMousePosition.x,
                        y: e.offsetY - previousMousePosition.y
                    };
                    proteinGroup.rotation.y += deltaMove.x * 0.01;
                    proteinGroup.rotation.x += deltaMove.y * 0.01;
                }
                previousMousePosition = { x: e.offsetX, y: e.offsetY };
            });
            
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                camera.position.z += e.deltaY * 0.05;
                camera.position.z = Math.max(20, Math.min(100, camera.position.z));
            });
            
            window.addEventListener('resize', () => {
                camera.aspect = viewer.clientWidth / viewer.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(viewer.clientWidth, viewer.clientHeight);
            });
            
            animate();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (proteinGroup && isSpinning) {
                proteinGroup.rotation.y += 0.005;
            }
            
            renderer.render(scene, camera);
        }
        
        function log(message, type = 'normal') {
            const logEl = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = 'log-entry ' + type;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
        }
        
        function setPreset(name) {
            const seq = typeof PRESETS[name] === 'function' ? PRESETS[name]() : PRESETS[name];
            document.getElementById('sequence').value = seq;
            log(`Loaded preset: ${name}`, 'info');
        }
        
        function setRenderMode(mode) {
            renderMode = mode;
            document.querySelectorAll('.control-btn').forEach((btn, i) => {
                btn.classList.toggle('active', i === ['cartoon', 'backbone', 'spacefill'].indexOf(mode));
            });
            if (proteinGroup) {
                const seq = document.getElementById('sequence').value.toUpperCase().replace(/[^A-Z]/g, '');
                visualizeStructure(seq, lastCoords, lastSecondary);
            }
        }
        
        function toggleSpin() {
            isSpinning = !isSpinning;
        }
        
        function toggleLabels() {
            showLabels = !showLabels;
            if (proteinGroup) {
                const seq = document.getElementById('sequence').value.toUpperCase().replace(/[^A-Z]/g, '');
                visualizeStructure(seq, lastCoords, lastSecondary);
            }
        }
        
        function resetViewer() {
            camera.position.set(0, 0, 50);
            if (proteinGroup) {
                proteinGroup.rotation.set(0, 0, 0);
            }
        }
        
        let lastCoords = null;
        let lastSecondary = null;
        
        async function startFolding() {
            const sequence = document.getElementById('sequence').value.toUpperCase().replace(/[^A-Z]/g, '');
            const iterations = parseInt(document.getElementById('iterations').value);
            const temperature = parseFloat(document.getElementById('temperature').value);
            const algorithm = document.getElementById('algorithm').value;
            
            if (sequence.length < 5) {
                log('Sequence must be at least 5 residues', 'error');
                return;
            }
            
            const btn = document.getElementById('fold-btn');
            btn.disabled = true;
            btn.innerHTML = '‚ö° Folding... <span class="loading">üß¨</span>';
            
            log(`Starting ${algorithm} folding for ${sequence.length} residues...`, 'info');
            document.getElementById('info-length').textContent = sequence.length;
            document.getElementById('info-method').textContent = algorithm.toUpperCase();
            
            const startTime = performance.now();
            
            try {
                // 1. Predict secondary structure
                log('Predicting secondary structure...');
                const secondary = predictSecondaryStructure(sequence);
                
                // 2. Build initial 3D structure
                log('Building initial backbone...');
                let coords = buildInitialStructure(sequence, secondary);
                
                // 3. Energy minimization
                log(`Running ${algorithm} optimization...`);
                const result = await optimizeStructure(sequence, coords, secondary, {
                    iterations, temperature, algorithm
                });
                
                coords = result.coords;
                lastCoords = coords;
                lastSecondary = secondary;
                
                // 4. Visualize
                visualizeStructure(sequence, coords, secondary);
                
                // Update stats
                const elapsed = performance.now() - startTime;
                document.getElementById('stat-energy').textContent = result.energy.toFixed(1);
                document.getElementById('stat-rg').textContent = result.rg.toFixed(1);
                document.getElementById('stat-helix').textContent = Math.round(result.helixPct) + '%';
                document.getElementById('stat-sheet').textContent = Math.round(result.sheetPct) + '%';
                document.getElementById('info-confidence').textContent = Math.round(result.confidence) + '%';
                
                log(`‚úÖ Folding complete in ${(elapsed/1000).toFixed(2)}s`);
                log(`   Energy: ${result.energy.toFixed(1)} kcal/mol`);
                log(`   Rg: ${result.rg.toFixed(1)} √Ö`);
                
            } catch (error) {
                log(`Error: ${error.message}`, 'error');
            }
            
            btn.disabled = false;
            btn.innerHTML = '‚ö° Start Folding Simulation';
        }
        
        function predictSecondaryStructure(sequence) {
            // Chou-Fasman-like propensity prediction
            const helixProp = { A: 1.42, E: 1.51, L: 1.21, M: 1.45, K: 1.16, R: 0.98, Q: 1.11 };
            const sheetProp = { V: 1.70, I: 1.60, Y: 1.47, F: 1.38, W: 1.37, T: 1.19, L: 1.30 };
            
            const secondary = [];
            const windowSize = 5;
            
            for (let i = 0; i < sequence.length; i++) {
                let helixScore = 0, sheetScore = 0;
                
                for (let j = Math.max(0, i - windowSize); j <= Math.min(sequence.length - 1, i + windowSize); j++) {
                    const aa = sequence[j];
                    helixScore += helixProp[aa] || 1.0;
                    sheetScore += sheetProp[aa] || 1.0;
                }
                
                if (helixScore > sheetScore * 1.1 && helixScore > windowSize * 1.1) {
                    secondary.push('H');
                } else if (sheetScore > helixScore * 1.1 && sheetScore > windowSize * 1.1) {
                    secondary.push('E');
                } else {
                    secondary.push('C');
                }
            }
            
            return secondary;
        }
        
        function buildInitialStructure(sequence, secondary) {
            const coords = [];
            
            // Backbone geometry
            const CA_DISTANCE = 3.8; // CŒ±-CŒ± distance in √Ö
            const HELIX_RISE = 1.5;
            const HELIX_RADIUS = 2.3;
            const HELIX_TURN = (100 * Math.PI) / 180; // ~100¬∞ per residue
            
            let x = 0, y = 0, z = 0;
            let theta = 0;
            let inHelix = false;
            let helixStart = 0;
            
            for (let i = 0; i < sequence.length; i++) {
                if (secondary[i] === 'H') {
                    // Œ±-helix geometry: 3.6 residues per turn
                    if (!inHelix) {
                        inHelix = true;
                        helixStart = i;
                    }
                    const helixI = i - helixStart;
                    const helixTheta = helixI * HELIX_TURN;
                    x = HELIX_RADIUS * Math.cos(helixTheta) + helixStart * 1.5;
                    y = HELIX_RADIUS * Math.sin(helixTheta);
                    z = helixI * HELIX_RISE;
                } else if (secondary[i] === 'E') {
                    // Œ≤-sheet: extended conformation
                    inHelix = false;
                    x = i * 3.3;
                    y = (i % 2) * 0.5;
                    z = 0;
                } else {
                    // Coil: semi-random but connected
                    inHelix = false;
                    if (i > 0) {
                        const prevCoord = coords[i - 1];
                        const angle = Math.random() * Math.PI * 2;
                        const elevation = (Math.random() - 0.5) * Math.PI;
                        x = prevCoord.x + CA_DISTANCE * Math.cos(angle) * Math.cos(elevation);
                        y = prevCoord.y + CA_DISTANCE * Math.sin(angle) * Math.cos(elevation);
                        z = prevCoord.z + CA_DISTANCE * Math.sin(elevation);
                    }
                }
                
                coords.push({ x, y, z });
            }
            
            // Center the structure
            const cx = coords.reduce((s, c) => s + c.x, 0) / coords.length;
            const cy = coords.reduce((s, c) => s + c.y, 0) / coords.length;
            const cz = coords.reduce((s, c) => s + c.z, 0) / coords.length;
            coords.forEach(c => { c.x -= cx; c.y -= cy; c.z -= cz; });
            
            return coords;
        }
        
        async function optimizeStructure(sequence, coords, secondary, options) {
            const { iterations, temperature, algorithm } = options;
            let energy = calculateEnergy(sequence, coords);
            let bestCoords = JSON.parse(JSON.stringify(coords));
            let bestEnergy = energy;
            let temp = temperature / 100;
            
            for (let iter = 0; iter < iterations; iter++) {
                // Perturb random residue
                const idx = Math.floor(Math.random() * coords.length);
                const oldPos = { ...coords[idx] };
                
                // Small random move
                const moveScale = temp * 0.5;
                coords[idx].x += (Math.random() - 0.5) * moveScale;
                coords[idx].y += (Math.random() - 0.5) * moveScale;
                coords[idx].z += (Math.random() - 0.5) * moveScale;
                
                // Enforce bond length constraints
                if (idx > 0) {
                    const prev = coords[idx - 1];
                    const dist = Math.sqrt(
                        (coords[idx].x - prev.x) ** 2 +
                        (coords[idx].y - prev.y) ** 2 +
                        (coords[idx].z - prev.z) ** 2
                    );
                    if (dist > 4.5 || dist < 3.0) {
                        coords[idx] = oldPos;
                        continue;
                    }
                }
                
                const newEnergy = calculateEnergy(sequence, coords);
                const deltaE = newEnergy - energy;
                
                // Metropolis criterion
                if (deltaE < 0 || Math.random() < Math.exp(-deltaE / temp)) {
                    energy = newEnergy;
                    if (energy < bestEnergy) {
                        bestEnergy = energy;
                        bestCoords = JSON.parse(JSON.stringify(coords));
                    }
                } else {
                    coords[idx] = oldPos;
                }
                
                // Cooling schedule
                if (algorithm === 'sa' && iter % 50 === 0) {
                    temp *= 0.98;
                }
                
                // Update progress
                if (iter % 100 === 0) {
                    const pct = Math.round((iter / iterations) * 100);
                    document.getElementById('progress').style.width = pct + '%';
                    document.getElementById('progress-text').textContent = 
                        `Iteration ${iter}/${iterations} | Energy: ${energy.toFixed(1)}`;
                    await new Promise(r => setTimeout(r, 0));
                }
            }
            
            document.getElementById('progress').style.width = '100%';
            document.getElementById('progress-text').textContent = 'Complete';
            
            // Calculate final metrics
            const rg = calculateRadiusOfGyration(bestCoords);
            const helixCount = secondary.filter(s => s === 'H').length;
            const sheetCount = secondary.filter(s => s === 'E').length;
            
            return {
                coords: bestCoords,
                energy: bestEnergy,
                rg,
                helixPct: (helixCount / sequence.length) * 100,
                sheetPct: (sheetCount / sequence.length) * 100,
                confidence: Math.min(95, 50 + Math.abs(bestEnergy) * 2)
            };
        }
        
        function calculateEnergy(sequence, coords) {
            let energy = 0;
            
            for (let i = 0; i < coords.length; i++) {
                for (let j = i + 2; j < coords.length; j++) {
                    const dist = Math.sqrt(
                        (coords[i].x - coords[j].x) ** 2 +
                        (coords[i].y - coords[j].y) ** 2 +
                        (coords[i].z - coords[j].z) ** 2
                    );
                    
                    const aa_i = AA_PROPERTIES[sequence[i]] || AA_PROPERTIES['A'];
                    const aa_j = AA_PROPERTIES[sequence[j]] || AA_PROPERTIES['A'];
                    
                    // Lennard-Jones-like potential
                    if (dist < 3.0) {
                        energy += 100; // Steric clash
                    } else if (dist < 8.0) {
                        // Hydrophobic interaction
                        if (aa_i.hydropathy > 0 && aa_j.hydropathy > 0) {
                            energy -= (aa_i.hydropathy + aa_j.hydropathy) / dist;
                        }
                        
                        // Electrostatic
                        if (aa_i.type === 'positive' && aa_j.type === 'negative') {
                            energy -= 5 / dist;
                        } else if (aa_i.type === aa_j.type && 
                                   (aa_i.type === 'positive' || aa_i.type === 'negative')) {
                            energy += 3 / dist;
                        }
                    }
                }
            }
            
            return energy;
        }
        
        function calculateRadiusOfGyration(coords) {
            const cx = coords.reduce((s, c) => s + c.x, 0) / coords.length;
            const cy = coords.reduce((s, c) => s + c.y, 0) / coords.length;
            const cz = coords.reduce((s, c) => s + c.z, 0) / coords.length;
            
            const sumSq = coords.reduce((s, c) => 
                s + (c.x - cx) ** 2 + (c.y - cy) ** 2 + (c.z - cz) ** 2, 0);
            
            return Math.sqrt(sumSq / coords.length);
        }
        
        function visualizeStructure(sequence, coords, secondary) {
            // Clear previous
            if (proteinGroup) {
                scene.remove(proteinGroup);
            }
            proteinGroup = new THREE.Group();
            
            if (renderMode === 'cartoon' || renderMode === 'backbone') {
                // Draw backbone as tube
                const points = coords.map(c => new THREE.Vector3(c.x, c.y, c.z));
                
                if (renderMode === 'cartoon') {
                    // Create smooth curve
                    const curve = new THREE.CatmullRomCurve3(points);
                    const tubeGeometry = new THREE.TubeGeometry(curve, coords.length * 4, 0.4, 8, false);
                    const tubeMaterial = new THREE.MeshPhongMaterial({
                        color: 0x4488ff,
                        shininess: 50,
                        flatShading: false
                    });
                    const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
                    proteinGroup.add(tube);
                    
                    // Add helix ribbons
                    let helixStart = -1;
                    for (let i = 0; i <= secondary.length; i++) {
                        if (secondary[i] === 'H' && helixStart === -1) {
                            helixStart = i;
                        } else if (secondary[i] !== 'H' && helixStart !== -1) {
                            // Draw helix
                            const helixPoints = coords.slice(helixStart, i).map(c => 
                                new THREE.Vector3(c.x, c.y, c.z));
                            if (helixPoints.length > 2) {
                                const helixCurve = new THREE.CatmullRomCurve3(helixPoints);
                                const helixGeo = new THREE.TubeGeometry(helixCurve, helixPoints.length * 4, 1.2, 8, false);
                                const helixMat = new THREE.MeshPhongMaterial({
                                    color: 0xff6b9d,
                                    transparent: true,
                                    opacity: 0.7
                                });
                                proteinGroup.add(new THREE.Mesh(helixGeo, helixMat));
                            }
                            helixStart = -1;
                        }
                    }
                } else {
                    // Simple line backbone
                    const material = new THREE.LineBasicMaterial({ color: 0x4488ff, linewidth: 2 });
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    proteinGroup.add(new THREE.Line(geometry, material));
                }
            }
            
            // Draw residue spheres
            for (let i = 0; i < sequence.length; i++) {
                const aa = AA_PROPERTIES[sequence[i]] || AA_PROPERTIES['A'];
                const radius = renderMode === 'spacefill' ? 1.8 : 0.6;
                
                const geometry = new THREE.SphereGeometry(radius, 16, 16);
                const material = new THREE.MeshPhongMaterial({
                    color: aa.color,
                    shininess: 80
                });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(coords[i].x, coords[i].y, coords[i].z);
                proteinGroup.add(sphere);
                
                // Labels
                if (showLabels && (i % 5 === 0 || i === sequence.length - 1)) {
                    // Simple label using sprite (simplified)
                    const labelGeo = new THREE.SphereGeometry(0.3, 8, 8);
                    const labelMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                    const label = new THREE.Mesh(labelGeo, labelMat);
                    label.position.set(coords[i].x, coords[i].y + 2, coords[i].z);
                    proteinGroup.add(label);
                }
            }
            
            scene.add(proteinGroup);
        }
        
        function exportPDB() {
            if (!lastCoords) {
                log('No structure to export', 'error');
                return;
            }
            
            const sequence = document.getElementById('sequence').value.toUpperCase().replace(/[^A-Z]/g, '');
            let pdb = 'HEADER    AION GENERATED STRUCTURE\n';
            pdb += 'TITLE     PREDICTED PROTEIN STRUCTURE\n';
            
            const AA_3LETTER = {
                A: 'ALA', R: 'ARG', N: 'ASN', D: 'ASP', C: 'CYS',
                E: 'GLU', Q: 'GLN', G: 'GLY', H: 'HIS', I: 'ILE',
                L: 'LEU', K: 'LYS', M: 'MET', F: 'PHE', P: 'PRO',
                S: 'SER', T: 'THR', W: 'TRP', Y: 'TYR', V: 'VAL'
            };
            
            for (let i = 0; i < lastCoords.length; i++) {
                const aa = AA_3LETTER[sequence[i]] || 'UNK';
                const x = lastCoords[i].x.toFixed(3).padStart(8);
                const y = lastCoords[i].y.toFixed(3).padStart(8);
                const z = lastCoords[i].z.toFixed(3).padStart(8);
                const num = String(i + 1).padStart(5);
                const res = String(i + 1).padStart(4);
                pdb += `ATOM  ${num}  CA  ${aa} A${res}    ${x}${y}${z}  1.00  0.00           C\n`;
            }
            pdb += 'END\n';
            
            const blob = new Blob([pdb], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'protein_structure.pdb';
            a.click();
            
            log('Exported structure to PDB file', 'info');
        }
        
        // Initialize
        init3D();
        log('AION Complete Protein Folding System initialized', 'info');
        log('Enter a sequence and click "Start Folding Simulation"');
    </script>
</body>
</html>
